#pragma once

/*
JPS算法的“两个定义、三个规则”
定义一，强迫邻居（forced neighbour）：
    如果节点n是x的邻居，并且节点n的邻居有阻挡（不可行走的格子），并且从parent(x)、x、n的路径长度比其他任何从parent(x)到n且不经过x的路径短，
    其中parent(x)为路径中x的前一个点，则n为x的强迫邻居，x为n的跳点，例如图2.2.1中，寻找从S到E的路径时，K为I的强迫邻居（I为K的跳点）。
    这里不认为从H到K能走，因为对角线有阻挡（这点和论文不一致，但和代码一致，因为如果H到K能直接到达，会走进H右边的阻挡区，大部分的JPS开源代码根据论文都认为H到K能直接到达，所以存在穿越阻挡的情况），如果需要H到K可走，则K为H的强迫邻居（H为K的跳点）。                                                             
定义二，跳点（jump point）：
    （1）如果点y是起点或目标点，则y是跳点，例如图2.2.1中，S是起点也是跳点，E是目标点也是跳点；
    （2）如果y有强迫邻居则y是跳点， 例如I是跳点，请注意此类跳点和强迫邻居是伴生关系，从定义一强迫邻居的定义来看n是强迫邻居，x是跳点，
        二者的关系是伴生的，例如图2.2.1中K的邻居只有I是跳点，M虽然也是K的邻居，但M不是跳点，因为K不是M的强迫邻居；
    （3）如果parent(y)到y是对角线移动，并且y经过水平或垂直方向移动可以到达跳点，则y是跳点，例如图2.2.1中G是跳点，因为parent(G)为S，
        S到G为对角线移动，从G到跳点I为垂直方向移动，I是跳点，所以G也是跳点。 

规则一：
    JPS搜索跳点的过程中，如果直线方向（为了和对角线区分，直线方向代表水平方向和垂直方向，且不包括对角线等斜线方向，下文所说的直线均为水平方向和垂直方向）、
    对角线方向都可以移动，则首先在直线方向搜索跳点，再在对角线方向搜索跳点。
规则二：
    （1）如果从parent(x)到x是直线移动，n是x的邻居，若有从parent(x)到n的路径不经过x且路径长度小于或等于从parent(x)经过x到n的路径，
        则走到x后下一个点不会走到n；
    （2）如果从parent(x)到x是对角线移动，n是x的邻居，若有从parent(x)到n的路径不经过x且路径长度小于从
        parent(x)经过x到n的路径，则走到x后下一个点不会走到n（相关证明见论文）。
规则三：
    只有跳点才会加入openset，因为跳点会改变行走方向，而非跳点不会改变行走方向，最后寻找出来的路径点也都是跳点。
*/